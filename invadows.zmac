; This program is free software: you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation, either version 3 of the License, or
; (at your option) any later version.
;
; This program is distributed in the hope that it will be useful, but
; WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
; or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
; for more details.
;
; You should have received a copy of the GNU General Public License along
; with this program. If not, see https://www.gnu.org/licenses/



; ####################################
; ####################################
; ###                              ###
; ###                              ###
; ###     HARDWARE ENVIRONMENT     ###
; ###                              ###
; ###                              ###
; ####################################
; ####################################

; This software works on the hardware board that was developed by Midway
; and used for games from Gun Fight (1975) to Space Invaders II (1980).
;
; 8080 processor, starting execution at address $0000.
; 8kB of ROM from $0000 to $1FFF
; 8kB of RAM from $2000 to $3FFF
;     including 7kB framebuffer starting at $2400, 256x224 1-bit.
;     Rotated 90 degrees CCW seen from viewer.
;     MSB to the "left" (bottom after rotation)
;
; I/O ports for Space Invaders (including cocktail version)
;
; Inputs
;
; port 1 input
;   0 - coin, debounced (returns 1 once per coin, resets after read)
;   1 - 2P start
;   2 - 1P start
;   4 - 1P fire
;   5 - 1P left
;   6 - 1P right
;
; port 2 input
;   0,1 - DIP switches (number of ships from 3 to 6)
;   2 - DIP switch (0=hard, 1=easy)
;   4 - 2P fire
;   5 - 2P left
;   6 - 2P right
;   7 - DIP switch (show/hide coin info)
;
; Sounds
;
; port 3 output
;   0 - saucer (doesn't automatically stop)
;   1 - shot
;   2 - player hit
;   3 - invader hit
;   4 - extended play
;
; port 4 output
;   0 - invader motion A
;   1 - invader motion B
;   2 - invader motion C
;   3 - invader motion D
;   4 - saucer hit
;   5 - amplifier on/off
;
; Shifter
;
; port 2 output: number of bits to shift
; port 4 output: data stream
; port 3 input: data stream from port 4 shifted by number of bits
;               specifed in port 2
;
; Watchdog
;
; port 6 output: any write will reset the watchdog



; ####################
; ####################
; ###              ###
; ###              ###
; ###     CODE     ###
; ###              ###
; ###              ###
; ####################
; ####################

	.8080			; Beware: Space Invaders uses a true 8080
				; but zmac and 8bitworkshop support full Z80
				; such that there's a risk that this code
				; might not work on actual hardware (or on
				; a strict emulator

	.org	0		; Execution starts at address 0

	DI			; There are no interrupts on the board.
				; Specifically, the only way to count time
				; is to count cycles

	LXI	SP,$2400	; Set up the stack at the top of the
				; scratch RAM

	CALL	bg		; Fill background

	MVI	B,0
	MVI	C,223
	MVI	D,0
	CALL	hwhite

	MVI	B,17
	MVI	C,84
	MVI	D,2
	CALL	hwhite

forever:
	OUT	6		; Tickle watchdog
	JMP	forever		; Main loop

; ##########################
; ##                      ##
; ##  BACKGROUND STIPPLE  ##
; ##                      ##
; ##########################

; Inputs: none
; Outputs: none
; Modifies: ABCHLF

bg:
	MVI	C,112		; 112 pairs of columns = 224 columns

	LXI	H,$2400		; Start address of framebuffer
bgcol:

	MVI	A,$55		; Pattern for even columns
	MVI	B,32		; 32 bytes per column
bgl32a:
	MOV	M,A
	INX	H
	DCR	B
	JNZ	bgl32a

	MVI	A,$AA		; Pattern for odd columns
	MVI	B,32		; 32 bytes per column
bgl32b:
	MOV	M,A
	INX	H
	DCR	B
	JNZ	bgl32b

	DCR	C
	JNZ	bgcol

	RET

; #######################
; ##                   ##
; ##  RECTANGLE WHITE  ##
; ##                   ##
; #######################

; Inputs: B: xleft
;         C: xright
;         D: ytop
;         E: ybottom

; Modifies: ABCDEHLF

rwhite:
	PUSH	B
	PUSH	D

; Compute address of bottom-left corner

; Multiply x by 32
	MOV	L,B
	MVI	H,0

	DAD	H
	DAD	H
	DAD	H
	DAD	H
	DAD	H

; Add base address
	LXI	B,$2400
	DAD	B

; Divide y by 8
	MOV	A,E
	CMA
	RRC
	RRC
	RRC
	ANI	31

; Add to the base address
	ADD	L
	MOV	L,A

	MOV	A,E
	CMA
	ANI	7

	MVI	A,$FF
	ADD	A
	ADD	A
	ADD	A
	ADD	A

	ORA	M
	MOV	M,A

	POP	D
	POP	B

	RET

; #############################
; ##                         ##
; ##  HORIZONTAL LINE WHITE  ##
; ##                         ##
; #############################

; Inputs: B: xleft
;         C: xright
;         D: y

hwhite:
; compute number of columns
	MOV	A,C
	SUB	B
	INR	A
	MOV	E,A

; address of the first column
	MOV	L,B
	MVI	H,0
	DAD	H
	DAD	H
	DAD	H
	DAD	H
	DAD	H
	LXI	B,$2400
	DAD	B

; address of first pixel
	MOV	A,D
	CMA
	RRC
	RRC
	RRC
	ANI	31
	ADD	L
	MOV	L,A

; pattern of pixels
	MOV	A,D
	ANI	7
	MOV	B,A
	MVI	A,$80
	JZ	hwshiftdone
	DCR	B
hwshift:
	RRC
	DCR	B
	JP	hwshift
hwshiftdone:
	MOV	D,A

	LXI	B,32
hwpixloop:
	MOV	A,D
	ORA	M
	MOV	M,A
	DAD	B
	DCR	E
	JNZ	hwpixloop

	RET

; 345678901234567890123456789012345678901234567890123456789012345678901234567890
